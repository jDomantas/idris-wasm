module Core.Name

%default total

mutual
  ||| A Generated Name
  public export
  data GenName =
    ||| A name in a nested scope
    Nested Name Name |
    ||| An autogenerated name for a case block function
    CaseBlock Name Int |
    ||| An autogenerated name for a with block function
    WithBlock Name Int

  ||| A name for a term in Blodwen
  public export
  data Name =
    ||| A user provided name
    UN String |
    ||| A machine generated name
    MN String Int  |
    ||| A name in a hierarchical namespace, namespaces are in reverse order (innermost name first)
    NS (List String) Name  |
    ||| A machine generated metavariable name
    HN String Int |
    ||| An implicitly bound pattern variable name, and the parent function
    PV Name Name |
    ||| A display name, explicitly saying how it should be pretty printed
    DN String Name  |
    ||| Various kinds of generated names
    GN GenName

||| Get the tag of a generated name, in order to enable orderings
gnameTag : GenName -> Int
gnameTag (Nested _ _) = 0
gnameTag (CaseBlock _ _) = 1
gnameTag (WithBlock _ _) = 2

||| Get the tag of a name, in order to enable orderings
nameTag : Name -> Int
nameTag (UN _) = 0
nameTag (MN _ _) = 1
nameTag (NS _ _) = 2
nameTag (HN _ _) = 3
nameTag (PV _ _) = 4
nameTag (DN _ _) = 5
nameTag (GN _) = 6

mutual
  ||| Get the root of a generated name
  export
  gnameRoot : GenName -> String
  gnameRoot (Nested outer inner) = nameRoot inner
  gnameRoot (CaseBlock outer count) = nameRoot outer
  gnameRoot (WithBlock outer count) = nameRoot outer

  ||| Get the root of a name
  export
  nameRoot : Name -> String
  nameRoot (UN x) = x
  nameRoot (MN x y) = x
  nameRoot (NS xs x) = nameRoot x
  nameRoot (HN x y) = x
  nameRoot (PV x y) = nameRoot x
  nameRoot (DN x y) = nameRoot y
  nameRoot (GN x) = gnameRoot x

  ||| Try to get the root of a user provided name
  export
  userNameRoot : Name -> Maybe String
  userNameRoot (UN x) = Just x
  userNameRoot (MN x y) = Nothing
  userNameRoot (NS xs x) = userNameRoot x
  userNameRoot (HN x y) = Nothing
  userNameRoot (PV x y) = Nothing
  userNameRoot (DN x y) = Nothing
  userNameRoot (GN x) = Nothing

||| Test whether a name is a user provided name, or is a hierachy around a user provided name
export
isUserName : Name -> Bool
isUserName (UN _) = True
isUserName (NS _ n) = isUserName n
isUserName _ = False


||| Drop a namespace from a name
export
dropNS : Name -> Name
dropNS (NS _ n) = n
dropNS n = n

||| Intersperse a list of strings with a separator. e.g:
||| `showSep '-' ["soup", "dragon", "clanger"]`
||| produces
||| `"soup-dragon-clanger"`
export
showSep : String -> List String -> String
showSep sep [] = ""
showSep sep [x] = x
showSep sep (x :: xs) = x ++ sep ++ showSep sep xs

||| Check whether a given character is a valid identifier character
export
identChar : Char -> Bool
identChar x = isAlphaNum x || x == '_' || x == '\''

mutual
  export
  Show GenName where
    show (Nested outer inner) = show outer ++ ":" ++ show inner
    show (CaseBlock outer i) = "case-block-" ++ show i ++ "-in-" ++ show outer
    show (WithBlock outer i) = "with-block-" ++ show i ++ "-in-" ++ show outer

  export
  Show Name where
    show (UN str) = str
    show (MN str int) = "{" ++ str ++ ":" ++ show int ++ "}"
    show (NS ns n) = showSep "." (reverse ns) ++ "." ++ show n
    show (HN str int) = "?" ++ str ++ "_" ++ show int
    show (PV n d) = "{P:" ++ show n ++ ":" ++ show d ++ "}"
    show (DN n d) = "{D:" ++ n ++ ":" ++ show d ++ "}"
    show (GN gn) = show gn

mutual
  export
  Eq GenName where
    (==) (Nested x1 x2) (Nested y1 y2) = x1 == y1 && x2 == y2
    (==) (CaseBlock x1 x2) (CaseBlock y1 y2) = x1 == y1 && x2 == y2
    (==) (WithBlock x1 x2) (WithBlock y1 y2) = x1 == y1 && x2 == y2
    (==) _ _ = False

  export
  Eq Name where
    (==) (UN x) (UN y) = x == y
    -- Put the arguments which are more likely to differ first
    (==) (MN x y) (MN x' y') = y == y' && x == x'
    (==) (NS xs x) (NS xs' x') = x == x' && xs == xs'
    (==) (HN x y) (HN x' y') = y == y' && x == x'
    (==) (PV x y) (PV x' y') = x == x' && y == y'
    (==) (DN x y) (DN x' y') = x == x' && y == y'
    (==) (GN x) (GN y) = x == y
    (==) _ _ = False

-- There's no way I'm maintaining a DecEq instance for this without
-- deriving it automatically... this is boring enough...
-- Maybe there should be a type class for these - things which are
-- weaker than DecEq but nevertheless useful - at least until I work out
-- how to get deriving DecEq to work (and if we want to use that feature
-- here in any case... might be best to avoid extensions if there really
-- is a self hosting goal)
mutual
  export
  gnameEq : (x : GenName) -> (y : GenName) -> Maybe (x = y)
  gnameEq (Nested x1 y1) (Nested x2 y2) with (nameEq x1 x2)
    gnameEq (Nested x1 y1) (Nested x2 y2) | Nothing = Nothing
    gnameEq (Nested x1 y1) (Nested x2 y2) | (Just x) with (nameEq y1 y2)
      gnameEq (Nested x1 y1) (Nested x2 y2) | (Just x) | Nothing = Nothing
      gnameEq (Nested x2 y2) (Nested x2 y2) | (Just Refl) | (Just Refl) = Just Refl
  gnameEq (CaseBlock x1 y1) (CaseBlock x2 y2) with (nameEq x1 x2)
    gnameEq (CaseBlock x1 y1) (CaseBlock x2 y2) | Nothing = Nothing
    gnameEq (CaseBlock x1 y1) (CaseBlock x2 y2) | (Just x) with (decEq y1 y2)
      gnameEq (CaseBlock x1 y1) (CaseBlock x2 y2) | (Just x) | (No _) = Nothing
      gnameEq (CaseBlock x2 y2) (CaseBlock x2 y2) | (Just Refl) | (Yes Refl) = Just Refl
  gnameEq (WithBlock x1 y1) (WithBlock x2 y2) with (nameEq x1 x2)
    gnameEq (WithBlock x1 y1) (WithBlock x2 y2) | Nothing = Nothing
    gnameEq (WithBlock x1 y1) (WithBlock x2 y2) | (Just x) with (decEq y1 y2)
      gnameEq (WithBlock x1 y1) (WithBlock x2 y2) | (Just x) | (No _) = Nothing
      gnameEq (WithBlock x2 y2) (WithBlock x2 y2) | (Just Refl) | (Yes Refl) = Just Refl
  gnameEq _ _ = Nothing

  export
  nameEq : (x : Name) -> (y : Name) -> Maybe (x = y)
  nameEq (UN x) (UN y) with (decEq x y)
    nameEq (UN y) (UN y) | (Yes Refl) = Just Refl
    nameEq (UN x) (UN y) | (No contra) = Nothing
  nameEq (MN x t) (MN x' t') with (decEq x x')
    nameEq (MN x t) (MN x t') | (Yes Refl) with (decEq t t')
      nameEq (MN x t) (MN x t) | (Yes Refl) | (Yes Refl) = Just Refl
      nameEq (MN x t) (MN x t') | (Yes Refl) | (No contra) = Nothing
    nameEq (MN x t) (MN x' t') | (No contra) = Nothing
  nameEq (NS xs x) (NS ys y) with (decEq xs ys)
    nameEq (NS ys x) (NS ys y) | (Yes Refl) with (nameEq x y)
      nameEq (NS ys x) (NS ys y) | (Yes Refl) | Nothing = Nothing
      nameEq (NS ys y) (NS ys y) | (Yes Refl) | (Just Refl) = Just Refl
    nameEq (NS xs x) (NS ys y) | (No contra) = Nothing
  nameEq (HN x t) (HN x' t') with (decEq x x')
    nameEq (HN x t) (HN x t') | (Yes Refl) with (decEq t t')
      nameEq (HN x t) (HN x t) | (Yes Refl) | (Yes Refl) = Just Refl
      nameEq (HN x t) (HN x t') | (Yes Refl) | (No contra) = Nothing
    nameEq (HN x t) (HN x' t') | (No contra) = Nothing
  nameEq (PV x t) (PV y t') with (nameEq x y)
    nameEq (PV y t) (PV y t') | (Just Refl) with (nameEq t t')
      nameEq (PV y t) (PV y t) | (Just Refl) | (Just Refl) = Just Refl
      nameEq (PV y t) (PV y t') | (Just Refl) | Nothing = Nothing
    nameEq (PV x t) (PV y t') | Nothing = Nothing
  nameEq (DN x t) (DN y t') with (decEq x y)
    nameEq (DN y t) (DN y t') | (Yes Refl) with (nameEq t t')
      nameEq (DN y t) (DN y t) | (Yes Refl) | (Just Refl) = Just Refl
      nameEq (DN y t) (DN y t') | (Yes Refl) | Nothing = Nothing
    nameEq (DN x t) (DN y t') | (No contra) = Nothing
  nameEq (GN x) (GN y) with (gnameEq x y)
    nameEq (GN x) (GN y) | Nothing = Nothing
    nameEq (GN x) (GN x) | (Just Refl) = Just Refl
  nameEq _ _ = Nothing

mutual
  export
  Ord GenName where
    compare (Nested x1 x2) (Nested y1 y2)
        = case compare x1 y1 of
               EQ => compare x2 y2
               GT => GT
               LT => LT
    compare (CaseBlock x1 x2) (CaseBlock y1 y2) 
        = case compare x1 y1 of
               EQ => compare x2 y2
               GT => GT
               LT => LT
    compare (WithBlock x1 x2) (WithBlock y1 y2) 
        = case compare x1 y1 of
               EQ => compare x2 y2
               GT => GT
               LT => LT
    compare x y = compare (gnameTag x) (gnameTag y)

  export
  Ord Name where
    compare (UN x) (UN y) = compare x y
    compare (MN x y) (MN x' y') 
        = case compare y y' of
               EQ => compare x x'
               GT => GT
               LT => LT
    compare (NS x y) (NS x' y') 
        = case compare y y' of -- Compare base name first (more likely to differ)
               EQ => compare x x'
               -- Because of the terrible way Idris 1 compiles 'case', this
               -- is actually faster than just having 't => t'...
               GT => GT
               LT => LT
    compare (HN x y) (HN x' y') 
        = case compare y y' of
               EQ => compare x x'
               GT => GT
               LT => LT
    compare (PV x y) (PV x' y')
        = case compare y y' of
               EQ => compare x x'
               GT => GT
               LT => LT
    compare (DN x y) (DN x' y')
        = case compare y y' of
               EQ => compare x x'
               GT => GT
               LT => LT
    compare (GN x) (GN y) = compare x y

    compare x y = compare (nameTag x) (nameTag y)

    (<=) x y = case compare x y of
                    GT => False
                    _ => True

hashString : String -> Int
hashString "" = 1
hashString xs
    = assert_total $
        cast (prim__strHead xs) + hashString (prim__strTail xs) * 31

export
hashName : Name -> Int
hashName x = hashString (show x)
